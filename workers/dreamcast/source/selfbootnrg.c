#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define NUM_SECTORS_IN_BUFFER 500  /* Must not be smaller than 456 */

/* Don't change these... */
#define NUM_AUDIO_SECTORS_PRE   150
#define NUM_AUDIO_SECTORS_POST  302
#define NUM_DATA_SECTORS_PRE    150
#define NUM_DATA_SECTORS_POST   2

static const unsigned long edctable[] = {
  0x00000000UL,0x90910101UL,0x91210201UL,0x01b00300UL,
  0x92410401UL,0x02d00500UL,0x03600600UL,0x93f10701UL,
  0x94810801UL,0x04100900UL,0x05a00a00UL,0x95310b01UL,
  0x06c00c00UL,0x96510d01UL,0x97e10e01UL,0x07700f00UL,
  0x99011001UL,0x09901100UL,0x08201200UL,0x98b11301UL,
  0x0b401400UL,0x9bd11501UL,0x9a611601UL,0x0af01700UL,
  0x0d801800UL,0x9d111901UL,0x9ca11a01UL,0x0c301b00UL,
  0x9fc11c01UL,0x0f501d00UL,0x0ee01e00UL,0x9e711f01UL,
  0x82012001UL,0x12902100UL,0x13202200UL,0x83b12301UL,
  0x10402400UL,0x80d12501UL,0x81612601UL,0x11f02700UL,
  0x16802800UL,0x86112901UL,0x87a12a01UL,0x17302b00UL,
  0x84c12c01UL,0x14502d00UL,0x15e02e00UL,0x85712f01UL,
  0x1b003000UL,0x8b913101UL,0x8a213201UL,0x1ab03300UL,
  0x89413401UL,0x19d03500UL,0x18603600UL,0x88f13701UL,
  0x8f813801UL,0x1f103900UL,0x1ea03a00UL,0x8e313b01UL,
  0x1dc03c00UL,0x8d513d01UL,0x8ce13e01UL,0x1c703f00UL,
  0xb4014001UL,0x24904100UL,0x25204200UL,0xb5b14301UL,
  0x26404400UL,0xb6d14501UL,0xb7614601UL,0x27f04700UL,
  0x20804800UL,0xb0114901UL,0xb1a14a01UL,0x21304b00UL,
  0xb2c14c01UL,0x22504d00UL,0x23e04e00UL,0xb3714f01UL,
  0x2d005000UL,0xbd915101UL,0xbc215201UL,0x2cb05300UL,
  0xbf415401UL,0x2fd05500UL,0x2e605600UL,0xbef15701UL,
  0xb9815801UL,0x29105900UL,0x28a05a00UL,0xb8315b01UL,
  0x2bc05c00UL,0xbb515d01UL,0xbae15e01UL,0x2a705f00UL,
  0x36006000UL,0xa6916101UL,0xa7216201UL,0x37b06300UL,
  0xa4416401UL,0x34d06500UL,0x35606600UL,0xa5f16701UL,
  0xa2816801UL,0x32106900UL,0x33a06a00UL,0xa3316b01UL,
  0x30c06c00UL,0xa0516d01UL,0xa1e16e01UL,0x31706f00UL,
  0xaf017001UL,0x3f907100UL,0x3e207200UL,0xaeb17301UL,
  0x3d407400UL,0xadd17501UL,0xac617601UL,0x3cf07700UL,
  0x3b807800UL,0xab117901UL,0xaaa17a01UL,0x3a307b00UL,
  0xa9c17c01UL,0x39507d00UL,0x38e07e00UL,0xa8717f01UL,
  0xd8018001UL,0x48908100UL,0x49208200UL,0xd9b18301UL,
  0x4a408400UL,0xdad18501UL,0xdb618601UL,0x4bf08700UL,
  0x4c808800UL,0xdc118901UL,0xdda18a01UL,0x4d308b00UL,
  0xdec18c01UL,0x4e508d00UL,0x4fe08e00UL,0xdf718f01UL,
  0x41009000UL,0xd1919101UL,0xd0219201UL,0x40b09300UL,
  0xd3419401UL,0x43d09500UL,0x42609600UL,0xd2f19701UL,
  0xd5819801UL,0x45109900UL,0x44a09a00UL,0xd4319b01UL,
  0x47c09c00UL,0xd7519d01UL,0xd6e19e01UL,0x46709f00UL,
  0x5a00a000UL,0xca91a101UL,0xcb21a201UL,0x5bb0a300UL,
  0xc841a401UL,0x58d0a500UL,0x5960a600UL,0xc9f1a701UL,
  0xce81a801UL,0x5e10a900UL,0x5fa0aa00UL,0xcf31ab01UL,
  0x5cc0ac00UL,0xcc51ad01UL,0xcde1ae01UL,0x5d70af00UL,
  0xc301b001UL,0x5390b100UL,0x5220b200UL,0xc2b1b301UL,
  0x5140b400UL,0xc1d1b501UL,0xc061b601UL,0x50f0b700UL,
  0x5780b800UL,0xc711b901UL,0xc6a1ba01UL,0x5630bb00UL,
  0xc5c1bc01UL,0x5550bd00UL,0x54e0be00UL,0xc471bf01UL,
  0x6c00c000UL,0xfc91c101UL,0xfd21c201UL,0x6db0c300UL,
  0xfe41c401UL,0x6ed0c500UL,0x6f60c600UL,0xfff1c701UL,
  0xf881c801UL,0x6810c900UL,0x69a0ca00UL,0xf931cb01UL,
  0x6ac0cc00UL,0xfa51cd01UL,0xfbe1ce01UL,0x6b70cf00UL,
  0xf501d001UL,0x6590d100UL,0x6420d200UL,0xf4b1d301UL,
  0x6740d400UL,0xf7d1d501UL,0xf661d601UL,0x66f0d700UL,
  0x6180d800UL,0xf111d901UL,0xf0a1da01UL,0x6030db00UL,
  0xf3c1dc01UL,0x6350dd00UL,0x62e0de00UL,0xf271df01UL,
  0xee01e001UL,0x7e90e100UL,0x7f20e200UL,0xefb1e301UL,
  0x7c40e400UL,0xecd1e501UL,0xed61e601UL,0x7df0e700UL,
  0x7a80e800UL,0xea11e901UL,0xeba1ea01UL,0x7b30eb00UL,
  0xe8c1ec01UL,0x7850ed00UL,0x79e0ee00UL,0xe971ef01UL,
  0x7700f000UL,0xe791f101UL,0xe621f201UL,0x76b0f300UL,
  0xe541f401UL,0x75d0f500UL,0x7460f600UL,0xe4f1f701UL,
  0xe381f801UL,0x7310f900UL,0x72a0fa00UL,0xe231fb01UL,
  0x71c0fc00UL,0xe151fd01UL,0xe0e1fe01UL,0x7070ff00UL,
};

static const unsigned char rs_l12_log[] = {
  0x00,0x00,0x01,0x19,0x02,0x32,0x1a,0xc6,
  0x03,0xdf,0x33,0xee,0x1b,0x68,0xc7,0x4b,
  0x04,0x64,0xe0,0x0e,0x34,0x8d,0xef,0x81,
  0x1c,0xc1,0x69,0xf8,0xc8,0x08,0x4c,0x71,
  0x05,0x8a,0x65,0x2f,0xe1,0x24,0x0f,0x21,
  0x35,0x93,0x8e,0xda,0xf0,0x12,0x82,0x45,
  0x1d,0xb5,0xc2,0x7d,0x6a,0x27,0xf9,0xb9,
  0xc9,0x9a,0x09,0x78,0x4d,0xe4,0x72,0xa6,
  0x06,0xbf,0x8b,0x62,0x66,0xdd,0x30,0xfd,
  0xe2,0x98,0x25,0xb3,0x10,0x91,0x22,0x88,
  0x36,0xd0,0x94,0xce,0x8f,0x96,0xdb,0xbd,
  0xf1,0xd2,0x13,0x5c,0x83,0x38,0x46,0x40,
  0x1e,0x42,0xb6,0xa3,0xc3,0x48,0x7e,0x6e,
  0x6b,0x3a,0x28,0x54,0xfa,0x85,0xba,0x3d,
  0xca,0x5e,0x9b,0x9f,0x0a,0x15,0x79,0x2b,
  0x4e,0xd4,0xe5,0xac,0x73,0xf3,0xa7,0x57,
  0x07,0x70,0xc0,0xf7,0x8c,0x80,0x63,0x0d,
  0x67,0x4a,0xde,0xed,0x31,0xc5,0xfe,0x18,
  0xe3,0xa5,0x99,0x77,0x26,0xb8,0xb4,0x7c,
  0x11,0x44,0x92,0xd9,0x23,0x20,0x89,0x2e,
  0x37,0x3f,0xd1,0x5b,0x95,0xbc,0xcf,0xcd,
  0x90,0x87,0x97,0xb2,0xdc,0xfc,0xbe,0x61,
  0xf2,0x56,0xd3,0xab,0x14,0x2a,0x5d,0x9e,
  0x84,0x3c,0x39,0x53,0x47,0x6d,0x41,0xa2,
  0x1f,0x2d,0x43,0xd8,0xb7,0x7b,0xa4,0x76,
  0xc4,0x17,0x49,0xec,0x7f,0x0c,0x6f,0xf6,
  0x6c,0xa1,0x3b,0x52,0x29,0x9d,0x55,0xaa,
  0xfb,0x60,0x86,0xb1,0xbb,0xcc,0x3e,0x5a,
  0xcb,0x59,0x5f,0xb0,0x9c,0xa9,0xa0,0x51,
  0x0b,0xf5,0x16,0xeb,0x7a,0x75,0x2c,0xd7,
  0x4f,0xae,0xd5,0xe9,0xe6,0xe7,0xad,0xe8,
  0x74,0xd6,0xf4,0xea,0xa8,0x50,0x58,0xaf,
};

static const unsigned char rs_l12_alog[] = {
  0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,
  0x1d,0x3a,0x74,0xe8,0xcd,0x87,0x13,0x26,
  0x4c,0x98,0x2d,0x5a,0xb4,0x75,0xea,0xc9,
  0x8f,0x03,0x06,0x0c,0x18,0x30,0x60,0xc0,
  0x9d,0x27,0x4e,0x9c,0x25,0x4a,0x94,0x35,
  0x6a,0xd4,0xb5,0x77,0xee,0xc1,0x9f,0x23,
  0x46,0x8c,0x05,0x0a,0x14,0x28,0x50,0xa0,
  0x5d,0xba,0x69,0xd2,0xb9,0x6f,0xde,0xa1,
  0x5f,0xbe,0x61,0xc2,0x99,0x2f,0x5e,0xbc,
  0x65,0xca,0x89,0x0f,0x1e,0x3c,0x78,0xf0,
  0xfd,0xe7,0xd3,0xbb,0x6b,0xd6,0xb1,0x7f,
  0xfe,0xe1,0xdf,0xa3,0x5b,0xb6,0x71,0xe2,
  0xd9,0xaf,0x43,0x86,0x11,0x22,0x44,0x88,
  0x0d,0x1a,0x34,0x68,0xd0,0xbd,0x67,0xce,
  0x81,0x1f,0x3e,0x7c,0xf8,0xed,0xc7,0x93,
  0x3b,0x76,0xec,0xc5,0x97,0x33,0x66,0xcc,
  0x85,0x17,0x2e,0x5c,0xb8,0x6d,0xda,0xa9,
  0x4f,0x9e,0x21,0x42,0x84,0x15,0x2a,0x54,
  0xa8,0x4d,0x9a,0x29,0x52,0xa4,0x55,0xaa,
  0x49,0x92,0x39,0x72,0xe4,0xd5,0xb7,0x73,
  0xe6,0xd1,0xbf,0x63,0xc6,0x91,0x3f,0x7e,
  0xfc,0xe5,0xd7,0xb3,0x7b,0xf6,0xf1,0xff,
  0xe3,0xdb,0xab,0x4b,0x96,0x31,0x62,0xc4,
  0x95,0x37,0x6e,0xdc,0xa5,0x57,0xae,0x41,
  0x82,0x19,0x32,0x64,0xc8,0x8d,0x07,0x0e,
  0x1c,0x38,0x70,0xe0,0xdd,0xa7,0x53,0xa6,
  0x51,0xa2,0x59,0xb2,0x79,0xf2,0xf9,0xef,
  0xc3,0x9b,0x2b,0x56,0xac,0x45,0x8a,0x09,
  0x12,0x24,0x48,0x90,0x3d,0x7a,0xf4,0xf5,
  0xf7,0xf3,0xfb,0xeb,0xcb,0x8b,0x0b,0x16,
  0x2c,0x58,0xb0,0x7d,0xfa,0xe9,0xcf,0x83,
  0x1b,0x36,0x6c,0xd8,0xad,0x47,0x8e,0x01,
  0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1d,
  0x3a,0x74,0xe8,0xcd,0x87,0x13,0x26,0x4c,
  0x98,0x2d,0x5a,0xb4,0x75,0xea,0xc9,0x8f,
  0x03,0x06,0x0c,0x18,0x30,0x60,0xc0,0x9d,
  0x27,0x4e,0x9c,0x25,0x4a,0x94,0x35,0x6a,
  0xd4,0xb5,0x77,0xee,0xc1,0x9f,0x23,0x46,
  0x8c,0x05,0x0a,0x14,0x28,0x50,0xa0,0x5d,
  0xba,0x69,0xd2,0xb9,0x6f,0xde,0xa1,0x5f,
  0xbe,0x61,0xc2,0x99,0x2f,0x5e,0xbc,0x65,
  0xca,0x89,0x0f,0x1e,0x3c,0x78,0xf0,0xfd,
  0xe7,0xd3,0xbb,0x6b,0xd6,0xb1,0x7f,0xfe,
  0xe1,0xdf,0xa3,0x5b,0xb6,0x71,0xe2,0xd9,
  0xaf,0x43,0x86,0x11,0x22,0x44,0x88,0x0d,
  0x1a,0x34,0x68,0xd0,0xbd,0x67,0xce,0x81,
  0x1f,0x3e,0x7c,0xf8,0xed,0xc7,0x93,0x3b,
  0x76,0xec,0xc5,0x97,0x33,0x66,0xcc,0x85,
  0x17,0x2e,0x5c,0xb8,0x6d,0xda,0xa9,0x4f,
  0x9e,0x21,0x42,0x84,0x15,0x2a,0x54,0xa8,
  0x4d,0x9a,0x29,0x52,0xa4,0x55,0xaa,0x49,
  0x92,0x39,0x72,0xe4,0xd5,0xb7,0x73,0xe6,
  0xd1,0xbf,0x63,0xc6,0x91,0x3f,0x7e,0xfc,
  0xe5,0xd7,0xb3,0x7b,0xf6,0xf1,0xff,0xe3,
  0xdb,0xab,0x4b,0x96,0x31,0x62,0xc4,0x95,
  0x37,0x6e,0xdc,0xa5,0x57,0xae,0x41,0x82,
  0x19,0x32,0x64,0xc8,0x8d,0x07,0x0e,0x1c,
  0x38,0x70,0xe0,0xdd,0xa7,0x53,0xa6,0x51,
  0xa2,0x59,0xb2,0x79,0xf2,0xf9,0xef,0xc3,
  0x9b,0x2b,0x56,0xac,0x45,0x8a,0x09,0x12,
  0x24,0x48,0x90,0x3d,0x7a,0xf4,0xf5,0xf7,
  0xf3,0xfb,0xeb,0xcb,0x8b,0x0b,0x16,0x2c,
  0x58,0xb0,0x7d,0xfa,0xe9,0xcf,0x83,0x1b,
  0x36,0x6c,0xd8,0xad,0x47,0x8e,
};

static const unsigned char DP0[] = {
  231,229,171,210,240,17,67,215,43,120,8,199,74,102,220,251,95,175,
  87,166,113,75,198,25,0
};
static const unsigned char DP1[] = {
  230,172,211,241,18,68,216,44,121,9,200,75,103,221,252,96,176,88,
  167,114,76,199,26,1,0
};
static const unsigned char DQ0[] = {
  190,96,250,132,59,81,159,154,200,7,111,245,10,20,41,156,168,79,173,
  231,229,171,210,240,17,67,215,43,120,8,199,74,102,220,251,95,175,
  87,166,113,75,198,25,0
};
static const unsigned char DQ1[] = {
  97,251,133,60,82,160,155,201,8,112,246,11,21,42,157,169,80,174,232,
  230,172,211,241,18,68,216,44,121,9,200,75,103,221,252,96,176,88,
  167,114,76,199,26,1,0
};

static void encode_P(const unsigned char *data, unsigned int sz, unsigned char *P)
{
  int i=0, j=0, n;
  memset(P, 0, 43*2*2);
  int dp0 = DP0[0], dp1 = DP1[0];
  for (n=0; n<sz; n++) {
    if (data[n]) {
      int base = rs_l12_log[data[n]];
      P[j] ^= rs_l12_alog[base + dp0];
      P[j+43*2] ^= rs_l12_alog[base + dp1];
    }
    if (++j == 2*43) { j=0; ++i; dp0 = DP0[i]; dp1 = DP1[i]; }
  }
}

static void encode_Q(const unsigned char *data, unsigned int sz, unsigned char *Q)
{
  int i=0, j=0, n;
  memset(Q, 0, 26*2*2);
  int dq0 = DQ0[0], dq1 = DQ1[0];
  for (n=0; n<sz; n++) {
    if (data[n]) {
      int base = rs_l12_log[data[n]];
      Q[j] ^= rs_l12_alog[base + dq0];
      Q[j+26*2] ^= rs_l12_alog[base + dq1];
    }
    if (j&1) {
      if (++i == 43)
	{ i = 0; j -= 16; }
      if ((j-=3)<0)
	j += 52;
      dq0 = DQ0[i]; dq1 = DQ1[i];
    } else j++;
  }
}

static void build_edc(const unsigned char *data, int sz, unsigned char *EDC)
{
  unsigned long r = 0;
  int n;
  for (n=0; n<sz; n++) {
    int v = data[n] ^ (r & 0xff);
    r = (r >> 8) ^ edctable[v];
  }
  EDC[0] = r&0xff;
  EDC[1] = (r>>8)&0xff;
  EDC[2] = (r>>16)&0xff;
  EDC[3] = (r>>24)&0xff;
}

static void convert_sector(const unsigned char *src, unsigned char *dst)
{
  static struct {
    unsigned char pad[4];
    unsigned char mode2_header[8];
    unsigned char data[2048];
    unsigned char edc[4];
    unsigned char p[43*2*2];
    unsigned char q[26*2*2];
  } buf;

  memset(&buf.pad[0], 0, sizeof(buf.pad)+sizeof(buf.mode2_header));
  memcpy(&buf.data[0], src, 2048);
  build_edc(&buf.mode2_header[0], sizeof(buf.mode2_header)+sizeof(buf.data), &buf.edc[0]);
  encode_P(&buf.pad[0], sizeof(buf.pad)+sizeof(buf.mode2_header)+sizeof(buf.data)+sizeof(buf.edc), &buf.p[0]);
  encode_Q(&buf.pad[0], sizeof(buf.pad)+sizeof(buf.mode2_header)+sizeof(buf.data)+sizeof(buf.edc)+sizeof(buf.p), &buf.q[0]);
  memcpy(dst, &buf.mode2_header[0], 2336);
}

static int fill_buffer(FILE *in, unsigned char *b, int cnt)
{
  int tot = 0;
  while (cnt > 0) {
    int r = fread(b, 2048, cnt, in);
    if (!r)
      break;
    b += (r<<11);
    tot += r;
    cnt -= r;
  }
  if (ferror(in)) {
    fprintf(stderr, "Read error!\n");
    exit(1);
  }
  return tot;
}

static unsigned long analyze_fs(const unsigned char *data, int cnt)
{
  int i;
  unsigned long sec;
  const unsigned char *pvd;

  for (i=16; i<cnt; i++)
    if (!memcmp(data+(i<<11), "\001CD001", 6))
      break;
    else if (!memcmp(data+(i<<11), "\377CD001", 6))
      i=cnt;
  if (i>=cnt) {
    fprintf(stderr, "Failed to locate Primary Volume Descriptor!\n");
    exit(1);
  }
  fprintf(stderr, "Primary Volume Descriptor located in sector %d\n", i);
  pvd = data+(i<<11);
  sec = pvd[0xa1];
  sec<<=8;
  sec |= pvd[0xa0];
  sec<<=8;
  sec |= pvd[0x9f];
  sec<<=8;
  sec |= pvd[0x9e];

  for (++i; i<cnt; i++)
    if (!memcmp(data+(i<<11), pvd+0x9c, 0x22))
      break;
  if (i>=cnt) {
    fprintf(stderr, "Failed to locate root directory!\n");
    exit(1);
  }
  fprintf(stderr, "Root directory located in sector %d\n", i);

  sec -= i;
  fprintf(stderr, "Session offset is %lu\n", sec);

  return sec;
}

static unsigned long convert_track(FILE *in, FILE *out, FILE *ipbin,
				   unsigned long *p_session_offset,
				   unsigned char *buf)
{
  int n, i;
  unsigned long tot = 0;
  while ((n = fill_buffer(in, buf, NUM_SECTORS_IN_BUFFER)) > 0) {
    if (!tot && ipbin) {
      fread(buf, 2048, 16, ipbin);
      if (ferror(ipbin)) {
	fprintf(stderr, "Read error on IP.bin!\n");
	exit(1);
      }
    }
    if (!tot && p_session_offset)
      *p_session_offset = analyze_fs(buf, n);
    for (i=n-1; i>=0; --i)
      convert_sector(buf+i*2048, buf+i*2336);
    fwrite(buf, 2336, n, out);
    tot += n;
  }
  return tot;
}

static void write_empty(FILE *out, unsigned char *buf, int sz, int cnt)
{
  memset(buf, 0, cnt*sz);
  fwrite(buf, sz, cnt, out);
}

static void put32(unsigned char *buf, unsigned long n)
{
  buf[0] = (n>>24)&0xff;
  buf[1] = (n>>16)&0xff;
  buf[2] = (n>>8)&0xff;
  buf[3] = n&0xff;
}

static void make_CUEX(unsigned char *buf, const unsigned long *params)
{
  memcpy(buf, "CUEX", 4);
  buf[7] = 32;
  buf[8] = params[0];
  put32(buf+12, params[2]);
  buf[16] = params[0];
  buf[17] = params[1];
  put32(buf+20, params[2]);
  buf[24] = params[0];
  buf[25] = params[1];
  buf[26] = 1;
  put32(buf+28, params[2]+params[3]);
  buf[32] = params[0];
  buf[33] = 0xaa;
  buf[34] = 1;
  put32(buf+36, params[2]+params[3]+params[4]);
}

static void make_DAOX(unsigned char *buf, const unsigned long *params)
{
  memcpy(buf, "DAOX", 4);
  buf[7] = 64;
  buf[11] = 64;
  buf[26] = params[0];
  buf[28] = params[1];
  buf[29] = params[1];
  put32(buf+40, params[2]);
  buf[44] = params[3];
  buf[47] = 1;
  put32(buf+52, params[4]);
  put32(buf+60, params[4]+params[5]);
  put32(buf+68, params[4]+params[5]+params[6]);
}

static void make_SINF(unsigned char *buf)
{
  memcpy(buf, "SINF", 4);
  buf[7] = 4;
  buf[11] = 1;
}

static void make_MTYP(unsigned char *buf)
{
  memcpy(buf, "MTYP", 4);
  buf[7] = 4;
  buf[11] = 1;
}

static void make_END_(unsigned char *buf)
{
  memcpy(buf, "END!", 4);
}

static void make_NER5(unsigned char *buf, unsigned long offs)
{
  memcpy(buf, "NER5", 4);
  put32(buf+8, offs);
}

static void write_footer(FILE *out, unsigned char *buf,
			 unsigned long data_sectors,
			 unsigned long session_offset)
{
  unsigned long cuex1[] = { 1, 1, (unsigned long)-NUM_AUDIO_SECTORS_PRE,
			    NUM_AUDIO_SECTORS_PRE, NUM_AUDIO_SECTORS_POST };
  unsigned long cuex2[] = { 0x41, 2, session_offset - NUM_DATA_SECTORS_PRE,
			    NUM_DATA_SECTORS_PRE,
			    data_sectors + NUM_DATA_SECTORS_POST };
  unsigned long daox1[] = { 0, 1, 2352, 7, 0, 2352UL*NUM_AUDIO_SECTORS_PRE,
			    2352UL*NUM_AUDIO_SECTORS_POST };
  unsigned long daox2[] = { 0x20, 2, 2336, 3,
			    2352UL*(NUM_AUDIO_SECTORS_PRE+NUM_AUDIO_SECTORS_POST),
			    2336UL*NUM_DATA_SECTORS_PRE,
			    2336UL*(data_sectors + NUM_DATA_SECTORS_POST) };
  memset(buf, 0, 280);
  make_CUEX(buf+0, cuex1);
  make_DAOX(buf+40, daox1);
  make_CUEX(buf+112, cuex2);
  make_DAOX(buf+152, daox2);
  make_SINF(buf+224);
  make_SINF(buf+236);
  make_MTYP(buf+248);
  make_END_(buf+260);
  make_NER5(buf+268, 2352UL*(NUM_AUDIO_SECTORS_PRE+NUM_AUDIO_SECTORS_POST)+2336UL*((NUM_DATA_SECTORS_PRE+NUM_DATA_SECTORS_POST)+data_sectors));
  fwrite(buf, 1, 280, out);
}

void convert_image(FILE *in, FILE *out, FILE *ipbin, void *buf)
{
  unsigned long data_sectors, session_offset;
  write_empty(out, buf, 2352, NUM_AUDIO_SECTORS_PRE+NUM_AUDIO_SECTORS_POST);
  write_empty(out, buf, 2336, NUM_DATA_SECTORS_PRE);
  data_sectors = convert_track(in, out, ipbin, &session_offset, buf);
  write_empty(out, buf, 2336, NUM_DATA_SECTORS_POST);
  write_footer(out, buf, data_sectors, session_offset);
  fflush(out);
  if (ferror(out)) {
    fprintf(stderr, "Write error!");
    exit(1);
  }
  fprintf(stderr, "Conversion complete.\n");
}

static void *buf = 0;
static FILE *ipbin = 0;

static void cleanup()
{
  if (buf) {
    free(buf);
    buf = 0;
  }
  if (ipbin) {
    fclose(ipbin);
    ipbin = 0;
  }
}

int main(int argc, char *argv[])
{
  atexit(cleanup);
#ifdef _O_BINARY
  /* Crappy W*ndows stdio... */
  if (_setmode(_fileno(stdin), _O_BINARY) < 0 ||
      _setmode(_fileno(stdout), _O_BINARY) < 0) {
    fprintf(stderr, "Failed to set stdio in binary mode!\n");
    return 1;
  }
#endif
  if (argc>1) {
    ipbin = fopen(argv[1], "rb");
    if (!ipbin) {
      fprintf(stderr, "Failed to open %s\n", argv[1]);
      return 1;
    }
  }
  buf = malloc(2336*NUM_SECTORS_IN_BUFFER);
  if (!buf) {
    fprintf(stderr, "Not enough memory!\n");
    return 1;
  }
  convert_image(stdin, stdout, ipbin, buf);
  return 0;
}
